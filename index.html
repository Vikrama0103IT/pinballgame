<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pinball â€“ Rigid Solid Flipper Logic</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body { margin: 0; background: #111; overflow: hidden; display: flex; align-items: center; justify-content: center; height: 100vh; width: 100vw; font-family: 'Segoe UI', Arial, sans-serif; touch-action: none; }
  #hud { position: absolute; top: 10px; width: 90%; display: flex; justify-content: space-between; color: white; z-index: 10; font-weight: bold; text-shadow: 2px 2px 4px #000; }
  canvas { background: #000; box-shadow: 0 0 50px rgba(0,0,0,1); }
</style>
</head>
<body>

<div id="hud">
  <div>SCORE: <span id="score">0</span></div>
  <div>BALLS: <span id="balls">3</span></div>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let W, H, scale, vH;
function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  scale = W / 440;
  vH = H / scale;
}
window.addEventListener("resize", resize);
resize();

/* ================= CONSTANTS ================= */
const PLAYFIELD_W = 440;
const WALL_BOUNCE = 0.5; 
const FLIPPER_LENGTH = 95; 
const MAX_SPEED = 18; 

const PIPE_WIDTH = 44; 
const PIPE_LEFT_LIMIT = PLAYFIELD_W - PIPE_WIDTH;
const PIPE_CENTER_X = PIPE_LEFT_LIMIT + PIPE_WIDTH / 2;
const PIPE_TOP_Y = 110;
const PIPE_CURVE_Y = 160;
const PIPE_RADIUS = 60;
const LEFT_CURVE_RADIUS = 100;

/* ================= STATE ================= */
let score = 0;
let balls = 3;
let springPress = 0;
let isPressingSpring = false;

const ball = {
  x: PIPE_CENTER_X,
  y: vH - 60,
  r: 16,
  vx: 0,
  vy: 0,
  active: true,
  inPipe: true,
  hitFlipper: false // Added hit flag
};

const bumpers = [
  { x: 220, y: 220, r: 25 },
  { x: 150, y: 350, r: 22 },
  { x: 290, y: 350, r: 22 }
];

const flippers = {
  left:  { x: 110, y: 0.88, rest: 0.5, active: -0.3, curr: 0.5, flipping: false, length: FLIPPER_LENGTH },
  right: { x: 330, y: 0.88, rest: -0.5, active: 0.3, curr: -0.5, flipping: false, length: FLIPPER_LENGTH }
};

/* ================= INPUT ================= */
function triggerFlipper(f) {
  if (f.flipping) return;
  f.flipping = true;
  f.curr = f.active;
  setTimeout(() => {
    f.curr = f.rest;
    f.flipping = false;
  }, 120);
}

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  const touchX = e.touches[0].clientX / scale;
  if (touchX > PIPE_LEFT_LIMIT && ball.inPipe) {
    isPressingSpring = true;
  } else {
    const side = e.touches[0].clientX < W / 2 ? "left" : "right";
    triggerFlipper(flippers[side]);
  }
}, { passive: false });

canvas.addEventListener("touchend", e => {
  if (isPressingSpring) {
    ball.vy = -6 - (springPress * 16); 
    isPressingSpring = false;
  }
});

/* ================= DRAW ================= */
function drawPlayfield() {
  ctx.save();
  ctx.scale(scale, scale);
  ctx.fillStyle = "#2d9b6d";
  ctx.fillRect(0, 0, PLAYFIELD_W, vH);

  const hingeY = vH * 0.88;
  ctx.fillStyle = "#000";
  ctx.beginPath(); ctx.moveTo(92, hingeY - 120); ctx.lineTo(110, hingeY); ctx.lineTo(47, hingeY - 50); ctx.fill();
  ctx.beginPath(); ctx.moveTo(348, hingeY - 120); ctx.lineTo(330, hingeY); ctx.lineTo(393, hingeY - 50); ctx.fill();

  ctx.strokeStyle = "#1e6fd9";
  ctx.lineWidth = 12;
  ctx.beginPath(); ctx.arc(0, 200, LEFT_CURVE_RADIUS, -Math.PI/2, Math.PI/2, false); ctx.stroke();

  bumpers.forEach(b => {
    ctx.fillStyle = "#d32f2f"; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.stroke();
  });

  const half = PIPE_WIDTH / 2;
  ctx.fillStyle = "#1e6fd9";
  ctx.beginPath();
  ctx.moveTo(PIPE_CENTER_X - half, vH); ctx.lineTo(PIPE_CENTER_X - half, PIPE_CURVE_Y);
  ctx.arc(PIPE_CENTER_X - PIPE_RADIUS, PIPE_CURVE_Y, PIPE_RADIUS - half, 0, -Math.PI/2, true);
  ctx.lineTo(PIPE_CENTER_X + half, PIPE_TOP_Y);
  ctx.arc(PIPE_CENTER_X - PIPE_RADIUS, PIPE_CURVE_Y, PIPE_RADIUS + half, -Math.PI/2, 0, false);
  ctx.lineTo(PIPE_CENTER_X + half, vH);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle = "#0a1b33"; ctx.lineWidth = 6; ctx.stroke();

  ctx.strokeStyle = "#ffd54f"; ctx.lineWidth = 3;
  const springBaseY = vH - 20; const compressionOffset = springPress * 40;
  for (let i = 0; i < 7; i++) {
    const yPos = springBaseY - (i * (6 - springPress * 4)) + compressionOffset;
    ctx.beginPath(); ctx.moveTo(PIPE_LEFT_LIMIT + 10, yPos); ctx.lineTo(PLAYFIELD_W - 10, yPos); ctx.stroke();
  }
  ctx.restore();
}

function drawFlipper(f, isLeft) {
  ctx.save();
  ctx.scale(scale, scale);
  ctx.translate(f.x, vH * f.y);
  ctx.rotate(f.curr);
  ctx.fillStyle = "#f5f5f5";
  ctx.beginPath();
  isLeft ? ctx.roundRect(0, -10, f.length, 20, 10) : ctx.roundRect(-f.length, -10, f.length, 20, 10);
  ctx.fill();
  ctx.restore();
}

/* ================= PHYSICS HELPERS ================= */
function checkFlipperCollision(f, isLeft) {
  if (ball.hitFlipper) return;

  const hx = f.x;
  const hy = vH * f.y;
  const dir = isLeft ? 1 : -1;

  // Added rotation calculation matching your flipper logic
  const tx = hx + Math.cos(f.curr) * f.length * dir;
  const ty = hy + Math.sin(f.curr) * f.length * dir;

  const dx = tx - hx;
  const dy = ty - hy;
  const t = Math.max(0, Math.min(1,
    ((ball.x - hx) * dx + (ball.y - hy) * dy) / (dx*dx + dy*dy)
  ));

  const cx = hx + t * dx;
  const cy = hy + t * dy;
  const dist = Math.hypot(ball.x - cx, ball.y - cy);

  if (dist < ball.r + 10) {
    const normal = Math.atan2(ball.y - cy, ball.x - cx);
    const force = f.flipping ? 18 : 6; // Increased flipping force for better feel

    ball.vx = Math.cos(normal) * force;
    ball.vy = Math.sin(normal) * force;

    ball.x = cx + Math.cos(normal) * (ball.r + 11);
    ball.y = cy + Math.sin(normal) * (ball.r + 11);
    ball.hitFlipper = true;
  }
}

/* ================= PHYSICS STEP (RUNS 10X PER FRAME) ================= */
function physicsStep() {
  if (ball.inPipe) {
    if (isPressingSpring) {
      ball.y = (vH - 60) + (springPress * 40);
      ball.vy = 0;
    } else {
      ball.y += ball.vy / 10;
      if (ball.y < PIPE_TOP_Y) { ball.inPipe = false; ball.x = PIPE_LEFT_LIMIT - ball.r - 5; ball.vx = -6; ball.vy = 1; }
      if (ball.y > vH - 60 && ball.vy >= 0) { ball.y = vH - 60; ball.vy = 0; }
    }
  } else {
    ball.vy += 0.35 / 10; 
    ball.x += ball.vx / 10;
    ball.y += ball.vy / 10;

    const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
    if (speed > MAX_SPEED) { ball.vx = (ball.vx / speed) * MAX_SPEED; ball.vy = (ball.vy / speed) * MAX_SPEED; }

    const hY = vH * 0.88;
    
    // Reset hit flag before checking flippers
    ball.hitFlipper = false;
    checkFlipperCollision(flippers.left, true);
    checkFlipperCollision(flippers.right, false);

    // Curve and Slingshot logic
    let distToLeftCurve = Math.sqrt(Math.pow(ball.x - 0, 2) + Math.pow(ball.y - 200, 2));
    if (distToLeftCurve < LEFT_CURVE_RADIUS + ball.r) {
      let angle = Math.atan2(ball.y - 200, ball.x - 0);
      ball.vx = Math.cos(angle) * 7; ball.vy = Math.sin(angle) * 7;
      ball.x = 0 + Math.cos(angle) * (LEFT_CURVE_RADIUS + ball.r + 1);
    }

    const pointInTriangle = (px, py, x1, y1, x2, y2, x3, y3) => {
      const area = 0.5 * Math.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));
      const area1 = 0.5 * Math.abs(px * (y1 - y2) + x1 * (y2 - py) + x2 * (py - y1));
      const area2 = 0.5 * Math.abs(px * (y2 - y3) + x2 * (y3 - py) + x3 * (py - y2));
      const area3 = 0.5 * Math.abs(px * (y3 - y1) + x3 * (y1 - py) + x1 * (py - y3));
      return Math.abs(area - (area1 + area2 + area3)) < 1.0;
    };

    if (pointInTriangle(ball.x, ball.y, 92, hY-120, 110, hY, 47, hY-50)) {
        ball.vx = -Math.abs(ball.vx) - 3; ball.vy = -10; score += 5;
    }
    if (pointInTriangle(ball.x, ball.y, 348, hY-120, 330, hY, 393, hY-50)) {
        ball.vx = Math.abs(ball.vx) + 3; ball.vy = -10; score += 5;
    }

    // Walls and boundaries
    if (ball.y > PIPE_TOP_Y && ball.x + ball.r > PIPE_LEFT_LIMIT) { ball.x = PIPE_LEFT_LIMIT - ball.r; ball.vx = -Math.abs(ball.vx) * WALL_BOUNCE; }
    if (ball.x - ball.r < 0) { ball.x = ball.r; ball.vx *= -WALL_BOUNCE; }
    if (ball.y - ball.r < 0) { ball.y = ball.r; ball.vy *= -WALL_BOUNCE; }
    
    bumpers.forEach(b => {
      let d = Math.sqrt((ball.x - b.x)**2 + (ball.y - b.y)**2);
      if (d < ball.r + b.r) { 
        let a = Math.atan2(ball.y - b.y, ball.x - b.x); 
        ball.vx = Math.cos(a) * 10; ball.vy = Math.sin(a) * 10; score += 10; 
      }
    });
  }

  if (ball.y > vH) { balls--; ball.x = PIPE_CENTER_X; ball.y = vH - 60; ball.vx = 0; ball.vy = 0; ball.inPipe = true; if (balls < 0) { alert("Game Over! Score: " + score); balls = 3; score = 0; } }
}

function update() {
    if (isPressingSpring) { if (springPress < 1) springPress += 0.02; } 
    else { if (springPress > 0) springPress -= 0.1; if (springPress < 0) springPress = 0; }
    for (let i = 0; i < 10; i++) { physicsStep(); }
}

function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawPlayfield(); update();
  ctx.save(); ctx.scale(scale, scale); ctx.fillStyle = "#ffca28"; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2); ctx.fill(); ctx.restore();
  drawFlipper(flippers.left, true); drawFlipper(flippers.right, false);
  ctx.save(); ctx.scale(scale, scale); const hY = vH * 0.88; [110, 330].forEach(x => { ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(x, hY, 11, 0, Math.PI * 2); ctx.fill(); }); ctx.restore();
  document.getElementById("score").innerText = score; document.getElementById("balls").innerText = balls;
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>